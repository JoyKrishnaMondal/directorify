// Generated by LiveScript 1.4.0
(function(){
  var browserify, fs, color, chokidar, delimit, ref$, ShowList, CopyDefaults, minDefaults, SeparateFilesAndDir, lo, colors, babelify, pathResolve, ErrorMain, log, isDirectory, Compile, SourceDirWatch, Main, isString, isNumber, AssumedDir, Defaults, InputLen, ConfigFile, Options;
  browserify = require("browserify");
  fs = require("fs");
  color = require("colors/safe");
  chokidar = require("chokidar");
  delimit = require('path').sep;
  ref$ = require("node-helpers"), ShowList = ref$.ShowList, CopyDefaults = ref$.CopyDefaults, minDefaults = ref$.minDefaults;
  SeparateFilesAndDir = require("SeparateFilesAndDirectories").SeparateFilesAndDir;
  lo = require("lodash");
  colors = require("colors");
  babelify = require("babelify");
  pathResolve = require("path").resolve;
  ErrorMain = function(ConfigFileName){
    return "Error: 'directorify' key is not populated in " + ConfigFileName + ", please check docs for help.";
  };
  log = function(string, replace){
    if (replace === false) {
      console.log(string);
      return;
    }
    process.stdout.clearLine();
    process.stdout.cursorTo(0);
    process.stdout.write(string);
  };
  isDirectory = function(path_string){
    return fs.lstatSync(path_string).isDirectory();
  };
  Compile = function(Options){
    return function(){
      var yellow, green, red, directorify, b;
      yellow = colors.yellow, green = colors.green, red = colors.red;
      directorify = Options.directorify;
      if (Options.browserify === undefined) {
        Options.browserify = {};
      }
      b = browserify(directorify.inputFile, Options.browserify);
      b.require(directorify.inputFile);
      if (!(Options.babelify === undefined)) {
        b = b.transform(babelify, Options.babelify);
      }
      b = b.exclude(directorify.exclude);
      return b.bundle(function(problem, buff){
        if (problem) {
          log(yellow("Browserify: " + red(problem.toString() + "\n")));
          return;
        }
        fs.writeFile(directorify.saveFile, buff.toString(), function(problem){
          var Text;
          if (problem) {
            console.error(red(problem));
            return;
          }
          Text = yellow("directorify|:" + green(directorify.count + yellow("| " + green(directorify.inputFile + yellow(" -> " + green(directorify.saveFile))))));
          log(Text);
          directorify.count += 1;
          return;
        });
      });
    };
  };
  SourceDirWatch = function(Options){
    var directorify;
    directorify = Options.directorify;
    return SeparateFilesAndDir(directorify.source, function(arg$){
      var Files, RegEx, JustFiles, i$, len$, I, Anly, Fn, watcher;
      Files = arg$.Files;
      RegEx = new RegExp("(.*)." + directorify.ext);
      JustFiles = [];
      for (i$ = 0, len$ = Files.length; i$ < len$; ++i$) {
        I = Files[i$];
        Anly = RegEx.exec(I);
        if (Anly) {
          JustFiles.push(Anly[1]);
        }
      }
      Fn = Compile(Options);
      for (i$ = 0, len$ = JustFiles.length; i$ < len$; ++i$) {
        I = JustFiles[i$];
        watcher = chokidar.watch(pathResolve(directorify.compile + delimit + I + directorify.target));
        watcher.on("change", Fn);
      }
      Fn();
      return;
    });
  };
  Main = function(Options){
    var directorify, Fn, watcher;
    directorify = Options.directorify;
    if (directorify.source === undefined) {
      minDefaults(Options.directorify, Defaults);
      Fn = Compile(Options);
      watcher = chokidar.watch(pathResolve(directorify.inputFile));
      watcher.on("change", Fn);
      return Fn();
    } else {
      minDefaults(Options.directorify, Defaults);
      return SourceDirWatch(Options);
    }
  };
  isString = lo.isString, isNumber = lo.isNumber;
  AssumedDir = {
    type: isString,
    value: "./"
  };
  Defaults = {
    inputFile: {
      type: isString
    },
    saveFile: {
      type: isString
    },
    source: AssumedDir,
    compile: AssumedDir,
    exclude: {
      type: isString,
      value: ""
    },
    ext: {
      type: isString,
      value: "ls"
    },
    target: {
      type: isString,
      value: ".js"
    },
    count: {
      type: isNumber,
      value: 0
    }
  };
  if (require.main === module) {
    InputLen = process.argv.length;
    switch (InputLen) {
    case 2:
      ConfigFile = "package.json";
      break;
    case 3:
      ConfigFile = process.argv[2];
    }
    Options = JSON.parse(fs.readFileSync(ConfigFile, {
      encoding: 'utf8'
    }));
    if (Options.directorify === undefined) {
      console.log(colors.red(ErrorMain(ConfigFile)));
    } else {
      Main(Options);
    }
  } else {
    module.exports = Main;
  }
}).call(this);
